<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java并发实现原理-多线程基础-InterruptedException函数与interrupt函数(2)</title>
      <link href="/fafa8499.html"/>
      <url>/fafa8499.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么情况下会考出InterruptedException"><a href="#1-什么情况下会考出InterruptedException" class="headerlink" title="1.什么情况下会考出InterruptedException?"></a>1.什么情况下会考出InterruptedException?</h2><p>Interrupt从字面意思看貌似是说，当一个线程运行到一半，将它中断，然后会抛出InterruptedException异常，然而并不是这样。</p><p>只有声明了会抛出InterruptedException的函数才会抛出异常。如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-轻量级阻塞与重量级阻塞"><a href="#2-轻量级阻塞与重量级阻塞" class="headerlink" title="2.轻量级阻塞与重量级阻塞"></a>2.轻量级阻塞与重量级阻塞</h2><p>轻量级阻塞：能够被中断的阻塞，对应的线程状态是WAITTING或者TIMED_WAITTING。</p><p>重量级阻塞：不能被中断的阻塞，对应状态是BLOCKED。像synchronized这种。</p><p>如下图，是调用不同函数之后，一个线程完整的状态迁移过程。</p><p><img src="https://cdn.jsdelivr.net/gh/Nesive/cdn@1.0.0/image/java_concurrency_principle/thread_state_transfer.png" alt="Java并发原理-线程的状态迁移过程"></p><p>初始线程处于NEW状态，调用start()之后开始执行，进入RUNNING或者READY状态。如果没有调用任何阻塞函数，线程只会在RUNNING和READY状态切换，即系统的时间片调度。这两种状态切换是由操作系统完成的，开发者基本没有机会介入，除了调用yield()函数，放弃对CPU的占用。</p><p>一旦调用了图中的任何函数，线程就会进入WAITTING或者TIMED_WAITTING状态，两者区别只是前者为无限期阻塞，后者传入了一个时间参数，阻塞了一个有限的时间。如果使用了synchronized关键字或者synchronized块，则会进入BLOCKED状态。</p><p>除了常见的阻塞/唤醒函数，还有一对不太常见的阻塞/唤醒函数,LockSupport.park() 和 LockSupport.unpark()。这对函数非常重要，Concurrent包中的Lock的实现即依赖这一对儿操作原语。</p><p>故而t.interrupted()函数的精确含义是<strong>“唤醒轻量阻塞”</strong>，而不是“中断一个线程”。</p><h2 id="3-t-interrupted-和Thread-interrupted-的区别"><a href="#3-t-interrupted-和Thread-interrupted-的区别" class="headerlink" title="3. t.interrupted()和Thread.interrupted()的区别"></a>3. t.interrupted()和Thread.interrupted()的区别</h2><p>因为t.interrupted()相当于给线程发送了一个唤醒的信号，所以如果线程此时恰好处于WAITTING或者TIMED_WAITTING状态，就会抛出一个InterrutedException,并且线程被唤醒。而如果线程此时没有被阻塞，则线程什么都不会做。但在后续，线程可以判断自己是否收到过其它线程发来的中断信号，然后做一些对应的处理。</p><p>这两个函数都是线程用于判断自己是否收到过中断信号的，前者是非静态函数，后者是静态函数。二者的区别在于，前者只是读取中断状态，不修改状态；后者不仅读取中断状态，还会重置中断标志位。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发实现原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发实现原理 </tag>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发实现原理-多线程基础-线程的优雅关闭(1)</title>
      <link href="/7f185260.html"/>
      <url>/7f185260.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-stop-与destory-函数"><a href="#1-stop-与destory-函数" class="headerlink" title="1.stop()与destory()函数"></a>1.stop()与destory()函数</h2><p>线程是“一种运行中的代码或者函数”。既然是运行中就会涉及到是一个问题，在运行中的线程是否可以强制结束/关闭？</p><p>答案是肯定不可以的。在Java中，stop()和destory()之类的函数是官方明确不建议使用的。原因是如果强制杀死线程，那么线程执行所占用的资源，eg:文件描述符、网络连接不能正常关闭。</p><p>因此，一个线程一旦运行，就不要强制去打断，合理的关闭办法是让它自然运行完（函数执行结束），干净的释放掉所有资源，然后退出。如果是一个不断循环的运行的线程，就需要用到线程的通讯机制，让主线程通知它退出。</p><h2 id="2-守护线程"><a href="#2-守护线程" class="headerlink" title="2.守护线程"></a>2.守护线程</h2><p>在下面代码中：在main()函数中开启一个线程，不断的循环打印。请问：当main()函数退出之后，线程是否会被强制退出？整个进程是否会强制退出？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main start..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">Thread</span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">try</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread1 executing.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedExcetpion</span> ex<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main end..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>答案是不会。在C语言中，main()函数退出后，整个程序就退出了，但在Java中并非如此。</p><p>对于如上程序，在thread1.start()前面加一行代码：thread1.setDeamon(true)。当main()函数执行结束后，线程thread1就会退出，整个进程也会退出。</p><p>当在JVM进程里面开启多个线程时，这些线程被分为两类：守护线程与非守护线程。默认开启的是非守护线程。在Java中规定：当所有非守护线程退出后，整个JVM进程就会退出。意思就是守护线程不影响整个JVM退出。eg:垃圾回收线程就是守护线程，他们在后台默默工作，当开发者的所有前台线程（非守护线程）都退出之后，整个JVM进程就退出了。</p><h2 id="3-设置关闭的标志位"><a href="#3-设置关闭的标志位" class="headerlink" title="3.设置关闭的标志位"></a>3.设置关闭的标志位</h2><p>在上面代码中，线程是一个死循环。但在实际工作中，开发人员通常不会这么写，而是通过标志位来实现。如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">boolean</span> stopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stopped<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>stopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token class-name">MyThread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通知线程t关闭</span>  t<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等待线程t退出while循环，自行退出</span>  t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码有一个问题：如过MyThread t在循环中阻塞在某个地方了，例如里面调用了object.wait()函数，那它可能永远没有机会再执行while(!stopped)的代码了，也就一直无法退出循环。</p><p>此时就要用到如下所讲的(<a href="/fafa8499.html" title="Java并发实现原理-多线程基础-InterruptedException函数与interrupt函数-2">Java并发实现原理-多线程基础-InterruptedException函数与interrupt函数-2</a>).</p>]]></content>
      
      
      <categories>
          
          <category> Java并发实现原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发实现原理 </tag>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
