<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nesive</title>
  
  
  <link href="https://blog.nesive.com/atom.xml" rel="self"/>
  
  <link href="https://blog.nesive.com/"/>
  <updated>2022-04-08T17:34:11.609Z</updated>
  <id>https://blog.nesive.com/</id>
  
  <author>
    <name>Nesive</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发实现原理-多线程基础-synchronized关键字(3)</title>
    <link href="https://blog.nesive.com/cd0cf4b7.html"/>
    <id>https://blog.nesive.com/cd0cf4b7.html</id>
    <published>2022-04-08T16:25:15.000Z</published>
    <updated>2022-04-08T17:34:11.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-锁的对象是什么？"><a href="#1-锁的对象是什么？" class="headerlink" title="1.锁的对象是什么？"></a>1.锁的对象是什么？</h2><p>对于不熟悉多线程原理的人来说，很容易误解synchronized关键字：它通常加在所有的静态成员函数和非静态成员函数之前，表面看好像是“函数之间的互斥”，其实不是。synchronized关键字其实是“给某个对象加了把锁”，这个锁究竟加在了什么对象上面？如下所示，给f1()、f2()加上synchronized关键字。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token keyword">synchronized</span> <span class="token function">fl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token keyword">synchronized</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>等价于如下代码:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于非静态成员函数，锁其实是加载对象a上面的；<br>对于静态成员函数，锁是加载A.class上面的。 当然，class本身也是对象。</p><p>这回答了一个关于synchronized的常见问题:一个静态成员函数和一个非静态成员函数，都加了synchronized关键字，分别被两个线程调用，他们是否互斥？很显然，因为是两把不同的锁，所以不会互斥。</p><h2 id="2-锁的本质是什么？"><a href="#2-锁的本质是什么？" class="headerlink" title="2.锁的本质是什么？"></a>2.锁的本质是什么？</h2><p>无论使用什么语言，只要是多线程的，就一定会涉及锁。既然锁如此常见，那么锁的本质是什么呢？</p><p>如图所示，多个线程访问同一个资源。线程就是一段运行中的代码；资源访问就是一个变量、一个对象或一个文件等；而锁就是要实现线程对资源的访问控制，保证同一个时间只能有一个线程去访问某一个资源。比如，线程就是一个游客，资源就是一个待参观的房子。这个房子同一时间值允许一个游客进去参观，当一个人出来后下一个人才能进去。而锁，就是这个房子门口的守卫。如果同一个时间允许多个游客参观，锁就会变成信号量，这点后面讨论。</p><p><img src="https://cdn.jsdelivr.net/gh/Nesive/nesive-butterfly-cdn/image/java_concurrency_principle/thread_lock_resource.png" alt="Java并发原理-线程的状态迁移过程"></p><p>从程序角度来看，锁就是一个“对象”,这个对象要完成以下几件事情：</p><p>1.这个对象内部得由一个标志位（state变量），记录自己有没有被某个线程占用（也就是记录当前有没有游客已经进入了房子）。最简单的情况是这个state有0和1两个取值，0标识没有线程占用，1标识某个线程占用了这个锁。</p><p>2.如果这个对象被某个线程占用，它得记录这个线程的thread ID,得知道自己是被那个线程占用了（也就是记录现在是谁在房子里面）。</p><p>3.这个对象还得维护一个thread id list，记录其他所有阻塞的、等待拿这个锁的线程（也就是记录所有在外面的等待的游客）。在当前线程释放锁之后（也就是把state从1变为0），从这个thread id list 里面去一个线程唤醒。</p><p>既然锁是一个“对象”，要访问的共享资源本身也是一个对象，例如前面的对象a，这两个对象可以合成一个对象。代码就变成synchronized(this){…}，我们要访问的共享资源是对象a,锁也加在a上面的。当然，也可以另外新建一个对象，代码变成synchronized(obj1){…}。这时访问的共享资源对象是a，而锁是加载新建的对象obj1上面的。</p><p>资源和锁合二为一，使得在Java里面，synchronized关键字可以加在任何对象的成员变量上。这意味着，这个对象既是共享资源，同时也具备“锁”的功能。下面来看Java是如何做到让任何一个对象都具备“锁”的功能的，这也是synchronized的实现原理。</p><h2 id="3-synchronized实现原理"><a href="#3-synchronized实现原理" class="headerlink" title="3.synchronized实现原理"></a>3.synchronized实现原理</h2><p>答案在Java的对象头里。在对象头里，有一个块数据较Mark Word。在64位机器上，<strong>Mark Word</strong>是8个字节（64位）的，这64位中有2个重要字段：锁标志位和占用该锁的thread ID。因为不同版本JVM的实现，对象头的数据结构会有差异，这里不再论述。</p><p>此处值说明锁的实现思路，后面将ReentrantLock详细实现时，也基于类似的思路。在这个思路上，synchronized还会有偏向、自旋等优化策略，ReentrantLock同样也会用到这些优化策略。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-锁的对象是什么？&quot;&gt;&lt;a href=&quot;#1-锁的对象是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.锁的对象是什么？&quot;&gt;&lt;/a&gt;1.锁的对象是什么？&lt;/h2&gt;&lt;p&gt;对于不熟悉多线程原理的人来说，很容易误解synchronized关键字：它通</summary>
      
    
    
    
    <category term="Java并发实现原理" scheme="https://blog.nesive.com/categories/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Java并发实现原理" scheme="https://blog.nesive.com/tags/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
    <category term="Java多线程" scheme="https://blog.nesive.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发实现原理-多线程基础-InterruptedException函数与interrupt函数(2)</title>
    <link href="https://blog.nesive.com/fafa8499.html"/>
    <id>https://blog.nesive.com/fafa8499.html</id>
    <published>2022-04-07T08:26:18.000Z</published>
    <updated>2022-04-08T17:14:42.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么情况下会考出InterruptedException"><a href="#1-什么情况下会考出InterruptedException" class="headerlink" title="1.什么情况下会考出InterruptedException?"></a>1.什么情况下会考出InterruptedException?</h2><p>Interrupt从字面意思看貌似是说，当一个线程运行到一半，将它中断，然后会抛出InterruptedException异常，然而并不是这样。</p><p>只有声明了会抛出InterruptedException的函数才会抛出异常。如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-轻量级阻塞与重量级阻塞"><a href="#2-轻量级阻塞与重量级阻塞" class="headerlink" title="2.轻量级阻塞与重量级阻塞"></a>2.轻量级阻塞与重量级阻塞</h2><p>轻量级阻塞：能够被中断的阻塞，对应的线程状态是WAITTING或者TIMED_WAITTING。</p><p>重量级阻塞：不能被中断的阻塞，对应状态是BLOCKED。像synchronized这种。</p><p>如下图，是调用不同函数之后，一个线程完整的状态迁移过程。</p><p><img src="https://cdn.jsdelivr.net/gh/Nesive/nesive-butterfly-cdn/image/java_concurrency_principle/thread_state_transfer.png" alt="Java并发原理-线程的状态迁移过程"></p><p>初始线程处于NEW状态，调用start()之后开始执行，进入RUNNING或者READY状态。如果没有调用任何阻塞函数，线程只会在RUNNING和READY状态切换，即系统的时间片调度。这两种状态切换是由操作系统完成的，开发者基本没有机会介入，除了调用yield()函数，放弃对CPU的占用。</p><p>一旦调用了图中的任何函数，线程就会进入WAITTING或者TIMED_WAITTING状态，两者区别只是前者为无限期阻塞，后者传入了一个时间参数，阻塞了一个有限的时间。如果使用了synchronized关键字或者synchronized块，则会进入BLOCKED状态。</p><p>除了常见的阻塞/唤醒函数，还有一对不太常见的阻塞/唤醒函数,LockSupport.park() 和 LockSupport.unpark()。这对函数非常重要，Concurrent包中的Lock的实现即依赖这一对儿操作原语。</p><p>故而t.interrupted()函数的精确含义是<strong>“唤醒轻量阻塞”</strong>，而不是“中断一个线程”。</p><h2 id="3-t-interrupted-和Thread-interrupted-的区别"><a href="#3-t-interrupted-和Thread-interrupted-的区别" class="headerlink" title="3. t.interrupted()和Thread.interrupted()的区别"></a>3. t.interrupted()和Thread.interrupted()的区别</h2><p>因为t.interrupted()相当于给线程发送了一个唤醒的信号，所以如果线程此时恰好处于WAITTING或者TIMED_WAITTING状态，就会抛出一个InterrutedException,并且线程被唤醒。而如果线程此时没有被阻塞，则线程什么都不会做。但在后续，线程可以判断自己是否收到过其它线程发来的中断信号，然后做一些对应的处理。</p><p>这两个函数都是线程用于判断自己是否收到过中断信号的，前者是非静态函数，后者是静态函数。二者的区别在于，前者只是读取中断状态，不修改状态；后者不仅读取中断状态，还会重置中断标志位。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么情况下会考出InterruptedException&quot;&gt;&lt;a href=&quot;#1-什么情况下会考出InterruptedException&quot; class=&quot;headerlink&quot; title=&quot;1.什么情况下会考出InterruptedException?&quot;</summary>
      
    
    
    
    <category term="Java并发实现原理" scheme="https://blog.nesive.com/categories/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Java并发实现原理" scheme="https://blog.nesive.com/tags/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
    <category term="Java多线程" scheme="https://blog.nesive.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发实现原理-多线程基础-线程的优雅关闭(1)</title>
    <link href="https://blog.nesive.com/7f185260.html"/>
    <id>https://blog.nesive.com/7f185260.html</id>
    <published>2022-04-07T07:07:36.000Z</published>
    <updated>2022-04-08T07:05:20.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-stop-与destory-函数"><a href="#1-stop-与destory-函数" class="headerlink" title="1.stop()与destory()函数"></a>1.stop()与destory()函数</h2><p>线程是“一种运行中的代码或者函数”。既然是运行中就会涉及到是一个问题，在运行中的线程是否可以强制结束/关闭？</p><p>答案是肯定不可以的。在Java中，stop()和destory()之类的函数是官方明确不建议使用的。原因是如果强制杀死线程，那么线程执行所占用的资源，eg:文件描述符、网络连接不能正常关闭。</p><p>因此，一个线程一旦运行，就不要强制去打断，合理的关闭办法是让它自然运行完（函数执行结束），干净的释放掉所有资源，然后退出。如果是一个不断循环的运行的线程，就需要用到线程的通讯机制，让主线程通知它退出。</p><h2 id="2-守护线程"><a href="#2-守护线程" class="headerlink" title="2.守护线程"></a>2.守护线程</h2><p>在下面代码中：在main()函数中开启一个线程，不断的循环打印。请问：当main()函数退出之后，线程是否会被强制退出？整个进程是否会强制退出？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main start..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">Thread</span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">try</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread1 executing.."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">InterruptedExcetpion</span> ex<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main end..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>答案是不会。在C语言中，main()函数退出后，整个程序就退出了，但在Java中并非如此。</p><p>对于如上程序，在thread1.start()前面加一行代码：thread1.setDeamon(true)。当main()函数执行结束后，线程thread1就会退出，整个进程也会退出。</p><p>当在JVM进程里面开启多个线程时，这些线程被分为两类：守护线程与非守护线程。默认开启的是非守护线程。在Java中规定：当所有非守护线程退出后，整个JVM进程就会退出。意思就是守护线程不影响整个JVM退出。eg:垃圾回收线程就是守护线程，他们在后台默默工作，当开发者的所有前台线程（非守护线程）都退出之后，整个JVM进程就退出了。</p><h2 id="3-设置关闭的标志位"><a href="#3-设置关闭的标志位" class="headerlink" title="3.设置关闭的标志位"></a>3.设置关闭的标志位</h2><p>在上面代码中，线程是一个死循环。但在实际工作中，开发人员通常不会这么写，而是通过标志位来实现。如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">boolean</span> stopped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stopped<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>stopped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token class-name">MyThread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通知线程t关闭</span>  t<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等待线程t退出while循环，自行退出</span>  t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码有一个问题：如过MyThread t在循环中阻塞在某个地方了，例如里面调用了object.wait()函数，那它可能永远没有机会再执行while(!stopped)的代码了，也就一直无法退出循环。</p><p>此时就要用到如下所讲的(<a href="/fafa8499.html" title="Java并发实现原理-多线程基础-InterruptedException函数与interrupt函数-2">Java并发实现原理-多线程基础-InterruptedException函数与interrupt函数-2</a>).</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-stop-与destory-函数&quot;&gt;&lt;a href=&quot;#1-stop-与destory-函数&quot; class=&quot;headerlink&quot; title=&quot;1.stop()与destory()函数&quot;&gt;&lt;/a&gt;1.stop()与destory()函数&lt;/h2&gt;&lt;p&gt;线程</summary>
      
    
    
    
    <category term="Java并发实现原理" scheme="https://blog.nesive.com/categories/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Java并发实现原理" scheme="https://blog.nesive.com/tags/Java%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
    <category term="Java多线程" scheme="https://blog.nesive.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
